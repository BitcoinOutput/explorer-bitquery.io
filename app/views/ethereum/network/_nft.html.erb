<div class="row">
  <div class="col-12 col-lg-12 mb-4">
    <div class="card">
      <div class="card-body">
        <div id="greenButton"></div>
        <div id="component_id" class='table table-striped table-hover table-sm widgets-table'></div>
      </div>
    </div>
  </div>
</div>

    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript"></script>

<script >
  
function errorAllert(element,error){
  element.textContent = '';
  element.classList.add('alert', 'alert-danger');
  element.setAttribute('role', 'alert');
  const title = document.createElement('h4');
  title.classList.add('alert-heading');
  const text = document.createElement('p')
  text.classList.add('mb-0');
  element.appendChild(title);
  element.appendChild(text);
  title.textContent = 'An error occurred while executing the request. Please, try again later';
  text.textContent = `Error: ${error[0].message}`;
}

class myBootstrapTableComponent {
  constructor(element) {
    this.container = element;
    this.tableElement = document.createElement('table');
    this.tableElement.classList.add('table', 'table-striped');
    this.thead = document.createElement('thead');
    this.tr = document.createElement('tr');
    this.container.appendChild(this.tableElement);
    this.tableElement.appendChild(this.thead);
    this.thead.appendChild(this.tr);
    this.config = this.configuration();
    this.config.columns.forEach(column => {
      const th = document.createElement('th');
      th.setAttribute('scope', 'col');
      th.textContent = column.name;
      this.tr.appendChild(th);
    });
    this.tbody = document.createElement('tbody');
    this.tableElement.appendChild(this.tbody);
  }
 
  onData = (data) => {
    console.log('onData',data);
    let array = this.config.topElement(data);
    array.forEach(rowData => {
      const tr = document.createElement('tr');
      this.tbody.appendChild(tr);
      let row = [];
      this.config.columns.forEach(column => {
        const td = document.createElement('td');
        td.textContent = column.cell(rowData);
        tr.appendChild(td);
      });
    });
  };
}

class GoogleChartsTableComponent {
  constructor(element, queryMetaInfo) {
    this.table = new google.visualization.Table(element);
    this.data = new google.visualization.DataTable();
    this.options = {
          allowHtml:true,
          showRowNumber: false,
          width: '100%',
          height: '100%',
          sortColumn: 0,
          sortAscending: false,
        }
    this.config = this.configuration();
    this.config.columns.forEach(column => 
  { this.data.addColumn(column.type ? column.type :'string', column.name);
  });
    this.table.draw(this.data, this.options);
    }

    onData = (data) => {
      let array = this.config.topElement(data)
      let rows = []
      array.forEach(rowData => {
        let row = []
        this.config.columns.forEach(column => row.push(column.cell(rowData)))
        rows.push(row)
      })
      this.data.addRows(rows)
      this.table.draw(this.data, this.options);
    };
}

const GRAPHQL_API = "<%= ENV['BITQUERY_IDE_API'] %>"

const graphqlQuerySubscriptionExecutor = async (url, query,componentObject,element,variables) =>{
  const currentUrl =  url.replace(/^http/, 'ws')  
  const client = createClient({url: currentUrl});
  const payload = {query: query}

  client.subscribe(payload, {
      next: async (data) => {
        // console.log('componentObject',componentObject)
        componentObject.onData(data.data);
       
      },
      error: (error) => {
        errorAllert(element,error);
        console.log('graphqlQuerySubscriptionExecutor',error)},
      complete: () => resolve(data)
  })
}

const graphqlQueryExecutor = async (url, query, element,variables, api_key = '') => {
  // console.log('query from graphqlQueryExecutor', query)
  let keyHeader = { 'X-API-KEY': api_key };
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
          ...keyHeader,
        },
        body: JSON.stringify({ query: query, variables: variables }),
        credentials: 'same-origin',
      });
      const data = await response.json();
      if(data.errors){
        errorAllert(element,data.errors)
      }
      return data;
    } catch (error) {
      console.error('graphqlQueryExecutor error:', error);
    }
};

function renderComponent(component,selector,queryId,prePopulateId,api_key,variables) {
  try {
    fetch(`${GRAPHQL_API}/getquery/${queryId}`)
      .then((response) => response.json())
      .then((queryMetaData) => {

          const compElement = document.querySelector(selector);
          const componentObject = new component(compElement, queryMetaData);
          const query = queryMetaData.query.trim();
          const queryVariables = variables; // TODO merge with query
          if (query.startsWith('subscription')) {
            document.querySelector('#greenButton').style.display = 'inline-block';
            // renderQueryInComponent(componentObject,prepopulateQuery(query,prePopulateId),compElement,queryVariables, api_key);
            graphqlQuerySubscriptionExecutor(queryMetaData.endpoint_url, prepopulateQuery(queryMetaData.endpoint_url, componentObject, compElement,query,prePopulateId), componentObject, compElement, queryVariables);
          } else {
            
            document.querySelector('#greenButton').style.display = 'none';
            renderQueryInComponent(queryMetaData.endpoint_url,componentObject,query,compElement,queryVariables, api_key);
          }
      })
      .catch((error) => console.log("fetch error:", error));
  } catch (error) {
    console.log("renderComponent error:", error);
  }
}

function prepopulateQuery(url, componentObject, compElement,query, prePopulateId){
  console.log('json', JSON.parse(query));
  if (prePopulateId) {


    if(!query.includes('limit')){
        renderQueryInComponent(url, componentObject, query.replace(/^subscription/,'query').replace(/Transfers\(/,'Transfers\(limit: {count: 15}'), compElement)
        return query.replace(/Transfers\(/,'Transfers\(limit: {count: 15}')
      }
    renderQueryInComponent(url, componentObject, query.replace(/^subscription/,'query'), compElement)
    return query
  } else {
      if(!query.includes('limit')){
        return query.replace(/Transfers\(/,'Transfers\(limit: {count: 15}')
        }
  
    return query
  }
}

function renderQueryInComponent(endpoint_url,componentObject,query,compElement,variables,api_key){
      graphqlQueryExecutor(endpoint_url, query, compElement, variables,api_key)
            .then((graphQLResponse) => componentObject.onData(graphQLResponse.data))
            .catch((error) => console.log("graphqlQueryExecutor error:", error));
}

//      ****** on page

class NFTStartTable extends myBootstrapTableComponent {
    configuration() {
      return  {
          topElement: function (response){ return response.EVM.Transfers },
          columns: [
            {
              name: 'Time', cell: function(row){ return row.Block.Time },
            },
            {
              name: 'Block', cell: function(row){ return row.Block.Number },
            },
            { 
              name: 'Currency', cell: function(row){ return row.Transfer.Currency.Symbol }
            },
            { 
              name: 'Reciver', cell: function(row){ return row.Reciver}
            },
          ]
        }
    }
}

google.charts.load('current', {'packages':['table']});
google.charts.setOnLoadCallback(
  function draw(){
    renderComponent(NFTStartTable, "#component_id", "Sub-Laset-Eth-NFT-tansfers", 'Laset-Eth-NFT-tansfers' );
  }
)

</script>
